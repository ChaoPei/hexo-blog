---
title: Linux 中进程和线程
date: 2017-02-25
update: 2018-04-12
categories: Linux
tags: [Linux, 线程, 进程, 操作系统]
---

总结协程、线程和进程的概念

<!--more-->

首先说说通用的进程、线程概念，顺便介绍一下协程

## 基本概念

### 进程

进程之间不共享任何状态，进程的调度由操作系统完成，每个进程都有自己的独立的内存空间，进程间的通讯主要是通过信号传递的方式来实现的，实现的方式有多种，信号量，管道，事件等，**任何一种方式的 IPC 通讯都需要通过内核，导致通讯效率比较低**。由于是独立的内存空间，上下文切换的时候需要保存先调用栈的信息，CPU 各寄存器的信息，虚拟内存，以及打开的相关句柄等信息，**所以导致上下文进程间切换开销很大**，通讯麻烦。

### 线程

线程之间共享变量，解决了通讯麻烦的问题，但**对变量的访问需要锁**，线程的调度主要也是有操作系统完成，一个进程可以拥有多个线程，但是其中**每个线程会共享父进程向操作系统申请资源，这个包括虚拟内存，打开的文件句柄等**，由于是共享资源，所以创建线程所需要的系统资源占用比进程小很多，相应的可创建的线程数量也变得相对多很多。线程时间的通讯除了可以使用进程之间通讯的方式之外还可以通过共享内存的方式进行通信，所以这个速度比通过内核要快很多。另外在调度方面也是由于内存是共享的，所以上下文切换的时候需要保存的东西就相对少一些，这样一来上下文切换也变得高效。**线程只拥有自己独立的线程 ID、栈空间、寄存器、程序计数器，其余在一个进程内的线程都是共享的**

### 协程

协程的调度完全由用户控制，一个线程可以有多个协程，用户创建了多个协程，然后每个协程都是循环按照指定的任务清单顺序完成不同的任务，当任务被堵塞的时候执行下一个任务，当恢复的时候再回来执行这个任务，**任务之间的切换只需要保存每个任务的上下文内容，就像直接操作栈一样的（和函数调用非常像），这样就完全没有内核切换的开销**，可以不加锁的访问全局变量，所以上下文的切换非常快；另外协程还需要保证是非堵塞的且没有相互依赖，**协程基本上不能同步通讯**，多采用异步的消息通讯，效率比较高。

## 进程和线程的比较

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，**进程是系统进行资源分配和调度的单位**。

线程是进程的一个实体，**是 CPU 调度和分派的基本单位**，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属于一个进程的其他的线程共享进程所拥有的全部资源。

### 线程与进程的关系

一个线程可以创建和销毁另一个线程，同一个进程中的多个线程之间可以并发执行。相对进程而言，线程是一个更加接近执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。但是有一点很重要，**进程中一个线程挂掉会导致整个进程也挂掉**

### 线程与进程的区别

进程与线程的主要差别在于它们是不同的操作系统的资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其他进程产生影响，而线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

* 一个程序至少有一个进程，一个进程至少有一个线程。
* 线程的划分尺度小于进程，使得多线程程序的并发性高。
* 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
* 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口，顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
* **从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别**。

### 线程与进程的优缺点

线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时线程适合于在 SMP 机器上运行，而进程则可以跨机器迁移。

### 进程和线程常用到的操作

* 进程：创建，销毁，创建子进程（fork），优先级。
* 线程：创建，挂起，恢复，销毁，切换，协作，睡眠，唤醒，等待，同步，锁，优先级

## Linux 中的线程

Linux 没有原生的多线程支持，线程是轻量级的进程。这样创建线程的方式和数据结构和进程类似，但是在切换效率上快很多。而且当进程占用资源比较大时，创建线程也比直接 `fork` 进程快得多。
