---
title: C++ 中 malloc 和 new 的区别
date: 2021-03-09 16:58:07
update: 2021-03-09 16:58:07
categories: C++
tags: [C++, malloc, new, operator new, delete, free]
---

C++ 中 malloc 和 new 都能开辟内存，这篇笔记记录 C++ 中 malloc 和 new 开辟新内存的区别。

<!-- more -->

#### 申请内存的位置不同：

* **new 操作符从自由存储区（free store）上为对象动态分配内存空间**，自由存储区是 C++ 基于 new 操作符的一个抽象概念，凡是通过 new 操作符进行内存申请，该内存即为自由存储区。自由存储区不仅可以是堆，还可以是静态存储区，这都    看 operator new 在哪里为对象分配内存。
* **malloc 函数从堆上动态分配内存**。

#### 返回类型的安全性

* new 操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故 new 是符合类型安全性的操作符。
* malloc 内存分配成功则是返回 void 指针 ，需要通过强制类型转换将 void 指针转换成我们需要的类型。

#### 内存分配失败时的返回值

* new 内存分配失败时，会抛出 bac_alloc 异常，它不会返回 NULL。
* malloc 分配失败时返回 NULL。

#### 分配内存大小

* 使用 new 操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。
* malloc 则需要明确指出所需内存的尺寸。

#### 是否调用构造函数/析构函数

* 使用 new 操作符来分配对象内存时会经历三个步骤：
    1. 调用 operator new 函数（对于数组是 operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。
    2. 编译器运行相应的构造函数以构造对象，并为其传入初值。
    3. 对象构造完成后，返回一个指向该对象的指针。
* 使用 delete 操作符来释放对象内存时会经历两个步骤：
    1. 调用对象的析构函数。
    2. 编译器调用operator delete(或operator delete[])函数释放内存空间。
* malloc不会调用构造函数，free也不会调用析构函数。

#### 对于数组的处理

* C++ 提供了 new[] 与 delete[] 来专门处理数组类型的分配。new 对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。
* 注意 delete[] 要与 new[] 配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。
* malloc 并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小

#### 是否可以被重载

opeartor new /operator delete 可以被重载。注意，new 表达式和 operator new 是不同的，前者调用后者，严格来说，我们区分的是 new 表达式和 malloc 表达式，所以应该都不支持重载。

#### 是否支持内存扩充

* new 不支持内存扩充
* malloc 在分配内存后，如果内存不足，可以**使用 realloc 进行内存重新分配**，实现扩充。